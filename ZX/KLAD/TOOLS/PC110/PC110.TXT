           ---------------------------------------
           !    * * *  ==== PC110 ====  * * *  !
           ---------------------------------------

              Транслятор PC110  ни  в  коем   случае  не
  . претендует  на альтернативу  стандартному языку  С и  компиляторам
  . систем  QC  и  QC2. Транслятор   предназначен  в  основном  для 
  . создания ассемблерных файлов (в формате ASM80) из текстов программ 
    написанных на псевдоСи.Данная версия транслятора поддерживает 
    ассемблерный код для процессора Z80.  

1. Описание PC110
{  ______________________
    . 
  1. Комментарии
  { ____________
    . Комментарии имеют вид /* ... */, комментарии могут
    . продолжаться на следующих строках
  } 
    .
  2. Идентификаторы
  { ____________
    . Идентификаторы  могут  иметь  произвольное  число  символов  в
    . пределах  строки,  но   значимы  только  первые  8   символов.
    . Среди  букв  и  цифр  допускается  знак  подчеркивания,  но не
    . вначале.
    .
    .    Иметь в  виду  чувствительность   идентификаторов  и   всех
    . других  символических  имен  к  размеру  букв  -  строчные или
    . прописные.
  } 
    .
  3. Ключевые слова
  { ____________
    . char,int,if,while,else,return,break,continue,goto
    . #define,#include,#asm,#endasm,#label,#list
  } 
    .
  4. Типы данных
  { ____________
      . 
    а/ константы:
      целые константы - 13,14,-32760
      спецсимволы /символьные константы / - 'a',';',...
      '\n' - конец строки
      '\t' - символ табуляции
      '\b' - символ  backspace
      '\r' - символ CR
      '\f' - символ FF
      '\\' - символ \
      '\0' - изображение кода 00
    б/ литералы /строковые константы /
      . имеют вид "...текст..."
      . длина строкового литерала до 70 байт
      . 
    в/ размер данных
      char - 1 байт
      int  - 2 байта
      . 
    в/ одномерные массивы, указатели
  } 
      .  из производных типов данных допустимы одномерные
      .  массивы с обьявлением вида 
      .  char <имя>[<число>]; или int <имя>[<число>];
      .  и массивы указателей с обьявлением вида
      . char *<имя>[<число>]; и int *<имя>[<число>]
      .
  5. Выражения
  { ____________
      . выражения образованы переменными, константами и 
      .   знаками операций:
      . присваивания   - =
      . арифметических - +,-,--,++,<<,>>
      . отношений      - ==,!=,<=,>=,<,>
      . битовых        - |
      . унарных        - &,*,(...)
      . 
    а/ операции над массивами и указателями
      . 
      . переменная,   обьявленная   как   массив   или   указатель,
      . содержит  адрес  области  памяти,  поэтому,  вообще  говоря,
      . допустимы  все  арифметические,  битовые  и унарные операции
      . над  такими  переменными.   Однако  на  практике  используют
      . лишь   линейные  арифметические   операции,  например,   для
      . перемещения по области массива на заданное число байт
      .
    б/ приоритет операций
      . 
      . по приоритету операции располагаются в следующем порядке
      . = | & == != <= >= < > >> << + - 
      . -- ++ * & (...)
      . 
  6. Cоставной оператор
  } 
      . 
      . составной   оператор   образуется   заключением   операторов
      . в фигурные скобки { ... }
      .
  7. Функции
  { ____________
      . 
    а/ Обьявление функции, уровень вложенности обьявлений
      . Обьявление функции имеет вид
      .
      . <имя функции> ( <аргументные переменные> )
      . char <обьявения>;
      . int  <обьявления>;
      . { 
      .   <операторы функции>
      . } 
      . 
      . Обратим внимание на то, что запятая после функции с аргументами
      . не ставится в отличие от формата вызова этой функции.
      .
  8. Описания
  { ____________
      . 
    а/ простые типы 
      . 
      . char <>;
      . int  <>;
      . 
    б/ указатели, массивы, массивы указателей
      . 
      . char *<имя>;
      . int  *<имя>;
      . char <имя>[<число>];
      . int  <имя>[<число>];
      . char *<имя>[<число>];
      . int  *<имя>[<число>];
      . char <имя>[];
      . int  <имя>[];
      . 
    в/ локальные переменные
      . 
      . локальные переменные и массивы обьявляются в фигурных
      . скобках, следующих за обьявлением функции
      . 
    г/ аргументные переменные
      . 
      . аргументные переменные и массивы обьявляются непосредственно
      . за обьявлением функции с параметрами, но перед фигурными
      . скобками.
      .
    д/ глобальные переменные
      . 
      . глобальные переменные обьявляются в промежутке между 
      . обьявлениями функций. Обьявления функций только 
      . одноуровневые, иными словами, не допускаются вложенные
      . определения.
      .
    е/ инициализация глобальных переменных
      . 
      . глобальные    переменные    и    массивы    инициализируются    
      . компилятором    нулевыми     значениями    всегда.  
      .
    ж/ классы памяти
      . 
      . локальные  и  аргументные   переменные  имеют  по   умолчанию
      . класс  памяти  auto,   тогда  как  глобальные  переменные   и
      . метки   имеют  тип   static  по   умолчанию,  такой   же  тип
      . имеют и строковые литералы
      .
    з/ совпадение имен
  } 
      . 
      . одинаковые  имена  локальных  переменных  в  разных  областях
      . обьявления  разных  функций  относятся  к  разным переменным,
      . поскольку  эти  переменные  располагаются  временно  в стеке.
      . Если  локальное  имя   совпадает  с  глобальным  именем,   то
      . приоритет  за локальным  именем. В компиляторе это выражается
      . в  том,  что   при  идентификации  имен  поиск   производится
      . сначала  в  таблице  локальных  имен,  и  лишь при отсутствии
      . -  в  таблице   глобальных  имен.  Различение  имен   функций
      . от  имен  глобальных   переменных  производится  по   первому
      . символу,  который  для  функций  есть  символ  подчеркивания,
      . которые   присоединяется   компилятором    к   имени  данному
      . программистом.    Внутренние    метки    имеют    стандартную
      . идентификацию   в  виде   _сс<число>,  поэтому   следует  это
      . учитывать   также   при   составлении   глобальных   имен   и
      . имен функций.
      .
    и/ метки
       метки используются командой GOTO имя_метки.
       Формат метки:
        :метка

  9. Препроцессор
  { ____________
      . 
    а/ подстановки #define
      . 
      . формат оператора 
      . #define <имя> <текст для замены>
      . С   момента    определения   имени   всякое   его   вхождение
      . будет    замещаться   на   текст   замены   однократно    без
      . попытки  замены  в  полученном  тексте.  Желательно   следить
      . за  тем,  чтобы  результат  не  вышел  за  размер 80 символов
      . в  строке.  Можно  учитывать,  что  при  подстановке  пробелы
      . упаковываются
      .
    б/ включение файлов #include
      . 
      . формат оператора
      . #include <имя файла с маршрутом>
      . Производится   включение    текста   из   указанного   файла.
      . Включаемый   текст   уже   не   может   содержать   этого   
      . оператора,  то  есть  уровень  вложенности  операторов  -  1.
      .     Имя  файла  не  заключается  в  уголки,  как  это   имеет
      . место  в  стандартном  языке  С   (  и  не  заключается  в   
      . кавычки ).
      .
    в/ включение asm-текста #asm, #endasm
  } 
      . 
      . формат оператора
      . #asm
      . .............................
      . ....<ассеблерная команда>....
      . ....<ассеблерная команда>....
      . .............................
      . #endasm
      . 
      .  Эти  операторы  исключительно  удачно сочетаются со свойством
      . компилятора  давать  на  выходе  как  раз  ассемблерный текст.
      . Их   использование   как   через   библиотеку   дополнительных   
      . функций, так  и непосредственно в  Micro-c-тексте, существенно
      . расширяет   возможности   языка   Micro-c,  позволяя    писать
      . программы,   использующие   средства   не  доступные    языкам
      . высокого    уровня    и,   в   частности,   стандартному    С.
      . Это  касается  написания  драйверов,  резидентных   программ,
      . перехвата  системных   прерываний.   Отметим  еще,  что   имея
      . это  в виду,  выходной файл  компилятора Micro-c  приспособлен
      . для  компиляции   в  .com-файлы,  а не в .ехе-файлы, поскольку
      . первые более предпочтительны для системных работ.
      .
   г/ команда #list
       эта команда включает режим вывода в ассемблерный файл строк
       из исходника на псевдоСи. Вывод начинается с места первого
       вхождения данной команды.

   д/ команда #label имя_метки
       эта команда определяет первые буквы меток в ассемблерном 
       файле.По умолчанию _cc.



  10. Сравнение со стандартным языком С 
  { ____________
    . 
    .    Для   тех,   кто   знаком   со   стандартным  языком  С можно
    . определить   PC110   как   строгое   подмножество  С следующим
    . образом: 
    . 1. Типы данных:
    .     символы
    .     целые
    .     строки
    .     массивы
    .     указатели
    . нет   вещественной  арифметики,   типов  static,  register.
    . 2. Нет   структур,  обьединений  и  многомерных   массивов.
    . 3. Нет deftype.
    . 4. Операции && и || заменяются на  &  и   |,  поразрядными.
    . 5. Нет  унарных  операций  !  и ~, которые выражаются через
    .    поразрядные
    . 6. Нет  операции  "запятая"  совместно  с конструкцией for.
    . 7. Нет  конструкций   сложных  присваиваний  вида += и т.д.
    . 8. Нет  switch, case, default, for, do-while.
    . 9. #include   не   могут   быть   вложенными
    . 10.Тип  static   заменяется   глобальным   описанием.
  } 
    .
  11. Некоторые дополнения и замечания
  { ____________
    .  
    . Обращаем внимание  на  различие между следующими конструкциями
    .  
    . if ( <A> & <B> ) ...<statement>...
    .  
    . и конструкцией вида
    .  
    . if ( <A> ) if ( <B> ) ...<statement>...
    .  
    .     Содержательно в  обоих  случаях  имеет  место  коньюнкция,
    . однако  в  первом  случае  производится   вычисление выражения 
    . и вычисление  всех подвыражений.   В то   время как  во втором 
    . случае если  первое подвыражение  окажется  ложным,  то второе 
    . уже не  вычисляется и  управление передается  в  другую  точку 
    . программы. Такое различие существенно отражается на выполнении 
    . программы,  например,  во  втором   подвыражении   может  быть  
    . инкрементация переменной цикла, или оператор ожидания.  
  } 
} 
